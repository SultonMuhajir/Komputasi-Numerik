{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Web Sulton Muhajir Nama : Sulton Muhajir NIM : 180411100048 Kelas : Komputasi Numerik 4B Dosen Pengampu : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Home"},{"location":"error/","text":"Pengertian Error / Galat Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Round off Error Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Truncation Error Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi. Inherent errors Terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error. Deret Maclaurin Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi. Algoritma Maclaurin Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut: Tugas Buatlah program dengan menghitung e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001 Jawab Listing Program import math x = 4 test = 1 a = 0 b = 1 while test > 0.001: fx = 0 fy = 0 for i in range(a): fx += (3**i)*x**i/math.factorial(i) for j in range(b): fy += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",a,\":\",fx) print(\"Suku ke-\",b,\":\",fy) test = fy - fx a+=1 b+=1 print(\"Hasil Selisih :\",test) print() Hasil Running Suku ke- 0 : 0 Suku ke- 1 : 1.0 Hasil Selisih : 1.0 Suku ke- 1 : 1.0 Suku ke- 2 : 13.0 Hasil Selisih : 12.0 Suku ke- 2 : 13.0 Suku ke- 3 : 85.0 Hasil Selisih : 72.0 Suku ke- 3 : 85.0 Suku ke- 4 : 373.0 Hasil Selisih : 288.0 Suku ke- 4 : 373.0 Suku ke- 5 : 1237.0 Hasil Selisih : 864.0 Suku ke- 5 : 1237.0 Suku ke- 6 : 3310.6 Hasil Selisih : 2073.6 Suku ke- 6 : 3310.6 Suku ke- 7 : 7457.799999999999 Hasil Selisih : 4147.199999999999 Suku ke- 7 : 7457.799999999999 Suku ke- 8 : 14567.285714285714 Hasil Selisih : 7109.4857142857145 Suku ke- 8 : 14567.285714285714 Suku ke- 9 : 25231.514285714286 Hasil Selisih : 10664.228571428572 Suku ke- 9 : 25231.514285714286 Suku ke- 10 : 39450.485714285714 Hasil Selisih : 14218.971428571429 Suku ke- 10 : 39450.485714285714 Suku ke- 11 : 56513.25142857143 Hasil Selisih : 17062.765714285713 Suku ke- 11 : 56513.25142857143 Suku ke- 12 : 75127.17766233766 Hasil Selisih : 18613.926233766237 Suku ke- 12 : 75127.17766233766 Suku ke- 13 : 93741.1038961039 Hasil Selisih : 18613.926233766237 Suku ke- 13 : 93741.1038961039 Suku ke- 14 : 110923.18965034965 Hasil Selisih : 17182.085754245752 Suku ke- 14 : 110923.18965034965 Suku ke- 15 : 125650.69172541745 Hasil Selisih : 14727.502075067794 Suku ke- 15 : 125650.69172541745 Suku ke- 16 : 137432.69338547168 Hasil Selisih : 11782.00166005423 Suku ke- 16 : 137432.69338547168 Suku ke- 17 : 146269.19463051236 Hasil Selisih : 8836.50124504068 Suku ke- 17 : 146269.19463051236 Suku ke- 18 : 152506.7249211293 Hasil Selisih : 6237.530290616938 Suku ke- 18 : 152506.7249211293 Suku ke- 19 : 156665.07844820726 Hasil Selisih : 4158.3535270779685 Suku ke- 19 : 156665.07844820726 Suku ke- 20 : 159291.4069916249 Hasil Selisih : 2626.3285434176505 Suku ke- 20 : 159291.4069916249 Suku ke- 21 : 160867.20411767552 Hasil Selisih : 1575.797126050602 Suku ke- 21 : 160867.20411767552 Suku ke- 22 : 161767.65961827585 Hasil Selisih : 900.4555006003357 Suku ke- 22 : 161767.65961827585 Suku ke- 23 : 162258.81716405787 Hasil Selisih : 491.1575457820145 Suku ke- 23 : 162258.81716405787 Suku ke- 24 : 162515.07327490064 Hasil Selisih : 256.25611084277625 Suku ke- 24 : 162515.07327490064 Suku ke- 25 : 162643.20133032204 Hasil Selisih : 128.12805542140268 Suku ke- 25 : 162643.20133032204 Suku ke- 26 : 162704.7027969243 Hasil Selisih : 61.501466602261644 Suku ke- 26 : 162704.7027969243 Suku ke- 27 : 162733.08808920227 Hasil Selisih : 28.385292277962435 Suku ke- 27 : 162733.08808920227 Suku ke- 28 : 162745.70377465914 Hasil Selisih : 12.61568545686896 Suku ke- 28 : 162745.70377465914 Suku ke- 29 : 162751.1104969978 Hasil Selisih : 5.406722338666441 Suku ke- 29 : 162751.1104969978 Suku ke- 30 : 162753.3477614138 Hasil Selisih : 2.237264416005928 Suku ke- 30 : 162753.3477614138 Suku ke- 31 : 162754.2426671802 Hasil Selisih : 0.8949057663849089 Suku ke- 31 : 162754.2426671802 Suku ke- 32 : 162754.58908231556 Hasil Selisih : 0.34641513536917046 Suku ke- 32 : 162754.58908231556 Suku ke- 33 : 162754.71898799133 Hasil Selisih : 0.12990567577071488 Suku ke- 33 : 162754.71898799133 Suku ke- 34 : 162754.7662264189 Hasil Selisih : 0.04723842756357044 Suku ke- 34 : 162754.7662264189 Suku ke- 35 : 162754.7828988051 Hasil Selisih : 0.016672386205755174 Suku ke- 35 : 162754.7828988051 Suku ke- 36 : 162754.7886150518 Hasil Selisih : 0.005716246698284522 Suku ke- 36 : 162754.7886150518 Suku ke- 37 : 162754.79052046736 Hasil Selisih : 0.0019054155563935637 Suku ke- 37 : 162754.79052046736 Suku ke- 38 : 162754.79113843996 Hasil Selisih : 0.0006179726042319089","title":"Error di Komputasi Numerik"},{"location":"error/#pengertian-error-galat","text":"Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati.","title":"Pengertian Error / Galat"},{"location":"error/#round-off-error","text":"Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer.","title":"Round off Error"},{"location":"error/#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.","title":"Truncation Error"},{"location":"error/#inherent-errors","text":"Terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error.","title":"Inherent errors"},{"location":"error/#deret-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi.","title":"Deret Maclaurin"},{"location":"error/#algoritma-maclaurin","text":"Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut:","title":"Algoritma Maclaurin"},{"location":"error/#tugas","text":"Buatlah program dengan menghitung e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001","title":"Tugas"},{"location":"error/#jawab","text":"","title":"Jawab"},{"location":"error/#listing-program","text":"import math x = 4 test = 1 a = 0 b = 1 while test > 0.001: fx = 0 fy = 0 for i in range(a): fx += (3**i)*x**i/math.factorial(i) for j in range(b): fy += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",a,\":\",fx) print(\"Suku ke-\",b,\":\",fy) test = fy - fx a+=1 b+=1 print(\"Hasil Selisih :\",test) print()","title":"Listing Program"},{"location":"error/#hasil-running","text":"Suku ke- 0 : 0 Suku ke- 1 : 1.0 Hasil Selisih : 1.0 Suku ke- 1 : 1.0 Suku ke- 2 : 13.0 Hasil Selisih : 12.0 Suku ke- 2 : 13.0 Suku ke- 3 : 85.0 Hasil Selisih : 72.0 Suku ke- 3 : 85.0 Suku ke- 4 : 373.0 Hasil Selisih : 288.0 Suku ke- 4 : 373.0 Suku ke- 5 : 1237.0 Hasil Selisih : 864.0 Suku ke- 5 : 1237.0 Suku ke- 6 : 3310.6 Hasil Selisih : 2073.6 Suku ke- 6 : 3310.6 Suku ke- 7 : 7457.799999999999 Hasil Selisih : 4147.199999999999 Suku ke- 7 : 7457.799999999999 Suku ke- 8 : 14567.285714285714 Hasil Selisih : 7109.4857142857145 Suku ke- 8 : 14567.285714285714 Suku ke- 9 : 25231.514285714286 Hasil Selisih : 10664.228571428572 Suku ke- 9 : 25231.514285714286 Suku ke- 10 : 39450.485714285714 Hasil Selisih : 14218.971428571429 Suku ke- 10 : 39450.485714285714 Suku ke- 11 : 56513.25142857143 Hasil Selisih : 17062.765714285713 Suku ke- 11 : 56513.25142857143 Suku ke- 12 : 75127.17766233766 Hasil Selisih : 18613.926233766237 Suku ke- 12 : 75127.17766233766 Suku ke- 13 : 93741.1038961039 Hasil Selisih : 18613.926233766237 Suku ke- 13 : 93741.1038961039 Suku ke- 14 : 110923.18965034965 Hasil Selisih : 17182.085754245752 Suku ke- 14 : 110923.18965034965 Suku ke- 15 : 125650.69172541745 Hasil Selisih : 14727.502075067794 Suku ke- 15 : 125650.69172541745 Suku ke- 16 : 137432.69338547168 Hasil Selisih : 11782.00166005423 Suku ke- 16 : 137432.69338547168 Suku ke- 17 : 146269.19463051236 Hasil Selisih : 8836.50124504068 Suku ke- 17 : 146269.19463051236 Suku ke- 18 : 152506.7249211293 Hasil Selisih : 6237.530290616938 Suku ke- 18 : 152506.7249211293 Suku ke- 19 : 156665.07844820726 Hasil Selisih : 4158.3535270779685 Suku ke- 19 : 156665.07844820726 Suku ke- 20 : 159291.4069916249 Hasil Selisih : 2626.3285434176505 Suku ke- 20 : 159291.4069916249 Suku ke- 21 : 160867.20411767552 Hasil Selisih : 1575.797126050602 Suku ke- 21 : 160867.20411767552 Suku ke- 22 : 161767.65961827585 Hasil Selisih : 900.4555006003357 Suku ke- 22 : 161767.65961827585 Suku ke- 23 : 162258.81716405787 Hasil Selisih : 491.1575457820145 Suku ke- 23 : 162258.81716405787 Suku ke- 24 : 162515.07327490064 Hasil Selisih : 256.25611084277625 Suku ke- 24 : 162515.07327490064 Suku ke- 25 : 162643.20133032204 Hasil Selisih : 128.12805542140268 Suku ke- 25 : 162643.20133032204 Suku ke- 26 : 162704.7027969243 Hasil Selisih : 61.501466602261644 Suku ke- 26 : 162704.7027969243 Suku ke- 27 : 162733.08808920227 Hasil Selisih : 28.385292277962435 Suku ke- 27 : 162733.08808920227 Suku ke- 28 : 162745.70377465914 Hasil Selisih : 12.61568545686896 Suku ke- 28 : 162745.70377465914 Suku ke- 29 : 162751.1104969978 Hasil Selisih : 5.406722338666441 Suku ke- 29 : 162751.1104969978 Suku ke- 30 : 162753.3477614138 Hasil Selisih : 2.237264416005928 Suku ke- 30 : 162753.3477614138 Suku ke- 31 : 162754.2426671802 Hasil Selisih : 0.8949057663849089 Suku ke- 31 : 162754.2426671802 Suku ke- 32 : 162754.58908231556 Hasil Selisih : 0.34641513536917046 Suku ke- 32 : 162754.58908231556 Suku ke- 33 : 162754.71898799133 Hasil Selisih : 0.12990567577071488 Suku ke- 33 : 162754.71898799133 Suku ke- 34 : 162754.7662264189 Hasil Selisih : 0.04723842756357044 Suku ke- 34 : 162754.7662264189 Suku ke- 35 : 162754.7828988051 Hasil Selisih : 0.016672386205755174 Suku ke- 35 : 162754.7828988051 Suku ke- 36 : 162754.7886150518 Hasil Selisih : 0.005716246698284522 Suku ke- 36 : 162754.7886150518 Suku ke- 37 : 162754.79052046736 Hasil Selisih : 0.0019054155563935637 Suku ke- 37 : 162754.79052046736 Suku ke- 38 : 162754.79113843996 Hasil Selisih : 0.0006179726042319089","title":"Hasil Running"},{"location":"root/","text":"Numerical Solution of Algebraic and Transcendental Equation Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma: Definisikan fungsi f(x) yang akan dicari akarnya Tentukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x = (a+b)/2 Hitung f(x) Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835 Regula Falsi Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Algoritma: Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : [ c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) ] Akar persamaanya = c Contoh Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259 Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Prosedur: Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Contoh Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035 Secant Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n [ x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) ] Akar persamaan adalah nilai x yang terakhir Contoh Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Numerical Solution"},{"location":"root/#numerical-solution-of-algebraic-and-transcendental-equation","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant.","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"root/#bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma: Definisikan fungsi f(x) yang akan dicari akarnya Tentukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x = (a+b)/2 Hitung f(x) Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835","title":"Bisection"},{"location":"root/#regula-falsi","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Algoritma: Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : [ c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) ] Akar persamaanya = c Contoh Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259","title":"Regula Falsi"},{"location":"root/#newton-raphson","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Prosedur: Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Contoh Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035","title":"Newton Raphson"},{"location":"root/#secant","text":"Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n [ x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) ] Akar persamaan adalah nilai x yang terakhir Contoh Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Secant"}]}