{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Web Sulton Muhajir Nama : Sulton Muhajir NIM : 180411100048 Kelas : Komputasi Numerik 4B Dosen Pengampu : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Home"},{"location":"error/","text":"Pengertian Error / Galat Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Round off Error Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Truncation Error Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi. Inherent errors Terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error. Deret Maclaurin Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi. Algoritma Maclaurin Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut: Tugas Buatlah program dengan menghitung e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001 Jawab Listing Program import math x = 4 test = 1 a = 0 b = 1 while test > 0.001: fx = 0 fy = 0 for i in range(a): fx += (3**i)*x**i/math.factorial(i) for j in range(b): fy += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",a,\":\",fx) print(\"Suku ke-\",b,\":\",fy) test = fy - fx a+=1 b+=1 print(\"Hasil Selisih :\",test) print() Hasil Running Suku ke- 0 : 0 Suku ke- 1 : 1.0 Hasil Selisih : 1.0 Suku ke- 1 : 1.0 Suku ke- 2 : 13.0 Hasil Selisih : 12.0 Suku ke- 2 : 13.0 Suku ke- 3 : 85.0 Hasil Selisih : 72.0 Suku ke- 3 : 85.0 Suku ke- 4 : 373.0 Hasil Selisih : 288.0 Suku ke- 4 : 373.0 Suku ke- 5 : 1237.0 Hasil Selisih : 864.0 Suku ke- 5 : 1237.0 Suku ke- 6 : 3310.6 Hasil Selisih : 2073.6 Suku ke- 6 : 3310.6 Suku ke- 7 : 7457.799999999999 Hasil Selisih : 4147.199999999999 Suku ke- 7 : 7457.799999999999 Suku ke- 8 : 14567.285714285714 Hasil Selisih : 7109.4857142857145 Suku ke- 8 : 14567.285714285714 Suku ke- 9 : 25231.514285714286 Hasil Selisih : 10664.228571428572 Suku ke- 9 : 25231.514285714286 Suku ke- 10 : 39450.485714285714 Hasil Selisih : 14218.971428571429 Suku ke- 10 : 39450.485714285714 Suku ke- 11 : 56513.25142857143 Hasil Selisih : 17062.765714285713 Suku ke- 11 : 56513.25142857143 Suku ke- 12 : 75127.17766233766 Hasil Selisih : 18613.926233766237 Suku ke- 12 : 75127.17766233766 Suku ke- 13 : 93741.1038961039 Hasil Selisih : 18613.926233766237 Suku ke- 13 : 93741.1038961039 Suku ke- 14 : 110923.18965034965 Hasil Selisih : 17182.085754245752 Suku ke- 14 : 110923.18965034965 Suku ke- 15 : 125650.69172541745 Hasil Selisih : 14727.502075067794 Suku ke- 15 : 125650.69172541745 Suku ke- 16 : 137432.69338547168 Hasil Selisih : 11782.00166005423 Suku ke- 16 : 137432.69338547168 Suku ke- 17 : 146269.19463051236 Hasil Selisih : 8836.50124504068 Suku ke- 17 : 146269.19463051236 Suku ke- 18 : 152506.7249211293 Hasil Selisih : 6237.530290616938 Suku ke- 18 : 152506.7249211293 Suku ke- 19 : 156665.07844820726 Hasil Selisih : 4158.3535270779685 Suku ke- 19 : 156665.07844820726 Suku ke- 20 : 159291.4069916249 Hasil Selisih : 2626.3285434176505 Suku ke- 20 : 159291.4069916249 Suku ke- 21 : 160867.20411767552 Hasil Selisih : 1575.797126050602 Suku ke- 21 : 160867.20411767552 Suku ke- 22 : 161767.65961827585 Hasil Selisih : 900.4555006003357 Suku ke- 22 : 161767.65961827585 Suku ke- 23 : 162258.81716405787 Hasil Selisih : 491.1575457820145 Suku ke- 23 : 162258.81716405787 Suku ke- 24 : 162515.07327490064 Hasil Selisih : 256.25611084277625 Suku ke- 24 : 162515.07327490064 Suku ke- 25 : 162643.20133032204 Hasil Selisih : 128.12805542140268 Suku ke- 25 : 162643.20133032204 Suku ke- 26 : 162704.7027969243 Hasil Selisih : 61.501466602261644 Suku ke- 26 : 162704.7027969243 Suku ke- 27 : 162733.08808920227 Hasil Selisih : 28.385292277962435 Suku ke- 27 : 162733.08808920227 Suku ke- 28 : 162745.70377465914 Hasil Selisih : 12.61568545686896 Suku ke- 28 : 162745.70377465914 Suku ke- 29 : 162751.1104969978 Hasil Selisih : 5.406722338666441 Suku ke- 29 : 162751.1104969978 Suku ke- 30 : 162753.3477614138 Hasil Selisih : 2.237264416005928 Suku ke- 30 : 162753.3477614138 Suku ke- 31 : 162754.2426671802 Hasil Selisih : 0.8949057663849089 Suku ke- 31 : 162754.2426671802 Suku ke- 32 : 162754.58908231556 Hasil Selisih : 0.34641513536917046 Suku ke- 32 : 162754.58908231556 Suku ke- 33 : 162754.71898799133 Hasil Selisih : 0.12990567577071488 Suku ke- 33 : 162754.71898799133 Suku ke- 34 : 162754.7662264189 Hasil Selisih : 0.04723842756357044 Suku ke- 34 : 162754.7662264189 Suku ke- 35 : 162754.7828988051 Hasil Selisih : 0.016672386205755174 Suku ke- 35 : 162754.7828988051 Suku ke- 36 : 162754.7886150518 Hasil Selisih : 0.005716246698284522 Suku ke- 36 : 162754.7886150518 Suku ke- 37 : 162754.79052046736 Hasil Selisih : 0.0019054155563935637 Suku ke- 37 : 162754.79052046736 Suku ke- 38 : 162754.79113843996 Hasil Selisih : 0.0006179726042319089","title":"Error in Numerical Computation"},{"location":"error/#pengertian-error-galat","text":"Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati.","title":"Pengertian Error / Galat"},{"location":"error/#round-off-error","text":"Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer.","title":"Round off Error"},{"location":"error/#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.","title":"Truncation Error"},{"location":"error/#inherent-errors","text":"Terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error.","title":"Inherent errors"},{"location":"error/#deret-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi.","title":"Deret Maclaurin"},{"location":"error/#algoritma-maclaurin","text":"Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut:","title":"Algoritma Maclaurin"},{"location":"error/#tugas","text":"Buatlah program dengan menghitung e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001","title":"Tugas"},{"location":"error/#jawab","text":"","title":"Jawab"},{"location":"error/#listing-program","text":"import math x = 4 test = 1 a = 0 b = 1 while test > 0.001: fx = 0 fy = 0 for i in range(a): fx += (3**i)*x**i/math.factorial(i) for j in range(b): fy += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",a,\":\",fx) print(\"Suku ke-\",b,\":\",fy) test = fy - fx a+=1 b+=1 print(\"Hasil Selisih :\",test) print()","title":"Listing Program"},{"location":"error/#hasil-running","text":"Suku ke- 0 : 0 Suku ke- 1 : 1.0 Hasil Selisih : 1.0 Suku ke- 1 : 1.0 Suku ke- 2 : 13.0 Hasil Selisih : 12.0 Suku ke- 2 : 13.0 Suku ke- 3 : 85.0 Hasil Selisih : 72.0 Suku ke- 3 : 85.0 Suku ke- 4 : 373.0 Hasil Selisih : 288.0 Suku ke- 4 : 373.0 Suku ke- 5 : 1237.0 Hasil Selisih : 864.0 Suku ke- 5 : 1237.0 Suku ke- 6 : 3310.6 Hasil Selisih : 2073.6 Suku ke- 6 : 3310.6 Suku ke- 7 : 7457.799999999999 Hasil Selisih : 4147.199999999999 Suku ke- 7 : 7457.799999999999 Suku ke- 8 : 14567.285714285714 Hasil Selisih : 7109.4857142857145 Suku ke- 8 : 14567.285714285714 Suku ke- 9 : 25231.514285714286 Hasil Selisih : 10664.228571428572 Suku ke- 9 : 25231.514285714286 Suku ke- 10 : 39450.485714285714 Hasil Selisih : 14218.971428571429 Suku ke- 10 : 39450.485714285714 Suku ke- 11 : 56513.25142857143 Hasil Selisih : 17062.765714285713 Suku ke- 11 : 56513.25142857143 Suku ke- 12 : 75127.17766233766 Hasil Selisih : 18613.926233766237 Suku ke- 12 : 75127.17766233766 Suku ke- 13 : 93741.1038961039 Hasil Selisih : 18613.926233766237 Suku ke- 13 : 93741.1038961039 Suku ke- 14 : 110923.18965034965 Hasil Selisih : 17182.085754245752 Suku ke- 14 : 110923.18965034965 Suku ke- 15 : 125650.69172541745 Hasil Selisih : 14727.502075067794 Suku ke- 15 : 125650.69172541745 Suku ke- 16 : 137432.69338547168 Hasil Selisih : 11782.00166005423 Suku ke- 16 : 137432.69338547168 Suku ke- 17 : 146269.19463051236 Hasil Selisih : 8836.50124504068 Suku ke- 17 : 146269.19463051236 Suku ke- 18 : 152506.7249211293 Hasil Selisih : 6237.530290616938 Suku ke- 18 : 152506.7249211293 Suku ke- 19 : 156665.07844820726 Hasil Selisih : 4158.3535270779685 Suku ke- 19 : 156665.07844820726 Suku ke- 20 : 159291.4069916249 Hasil Selisih : 2626.3285434176505 Suku ke- 20 : 159291.4069916249 Suku ke- 21 : 160867.20411767552 Hasil Selisih : 1575.797126050602 Suku ke- 21 : 160867.20411767552 Suku ke- 22 : 161767.65961827585 Hasil Selisih : 900.4555006003357 Suku ke- 22 : 161767.65961827585 Suku ke- 23 : 162258.81716405787 Hasil Selisih : 491.1575457820145 Suku ke- 23 : 162258.81716405787 Suku ke- 24 : 162515.07327490064 Hasil Selisih : 256.25611084277625 Suku ke- 24 : 162515.07327490064 Suku ke- 25 : 162643.20133032204 Hasil Selisih : 128.12805542140268 Suku ke- 25 : 162643.20133032204 Suku ke- 26 : 162704.7027969243 Hasil Selisih : 61.501466602261644 Suku ke- 26 : 162704.7027969243 Suku ke- 27 : 162733.08808920227 Hasil Selisih : 28.385292277962435 Suku ke- 27 : 162733.08808920227 Suku ke- 28 : 162745.70377465914 Hasil Selisih : 12.61568545686896 Suku ke- 28 : 162745.70377465914 Suku ke- 29 : 162751.1104969978 Hasil Selisih : 5.406722338666441 Suku ke- 29 : 162751.1104969978 Suku ke- 30 : 162753.3477614138 Hasil Selisih : 2.237264416005928 Suku ke- 30 : 162753.3477614138 Suku ke- 31 : 162754.2426671802 Hasil Selisih : 0.8949057663849089 Suku ke- 31 : 162754.2426671802 Suku ke- 32 : 162754.58908231556 Hasil Selisih : 0.34641513536917046 Suku ke- 32 : 162754.58908231556 Suku ke- 33 : 162754.71898799133 Hasil Selisih : 0.12990567577071488 Suku ke- 33 : 162754.71898799133 Suku ke- 34 : 162754.7662264189 Hasil Selisih : 0.04723842756357044 Suku ke- 34 : 162754.7662264189 Suku ke- 35 : 162754.7828988051 Hasil Selisih : 0.016672386205755174 Suku ke- 35 : 162754.7828988051 Suku ke- 36 : 162754.7886150518 Hasil Selisih : 0.005716246698284522 Suku ke- 36 : 162754.7886150518 Suku ke- 37 : 162754.79052046736 Hasil Selisih : 0.0019054155563935637 Suku ke- 37 : 162754.79052046736 Suku ke- 38 : 162754.79113843996 Hasil Selisih : 0.0006179726042319089","title":"Hasil Running"},{"location":"euler/","text":"Metode Euler Dalam matematika dan ilmu komputasi, metode euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu metode satu langkah paling sederhana. Dibandingkan dengan beberapa metode lain, metode ini paling tidak teliti. Namun, metode ini perlu dipelajari mengingat kesederhanaan dan pemahaman yang mudah sehingga membuatnya lebih mudah untuk mempelajari metode lain secara lebih menyeluruh. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan yi + 1 = yi + f(xi,yi) h dimana i merupakan tahap iterasi. Algoritma Metode Euler Tentukan titik awal integrasi x0 dan y0 Tentukan jumlah iterasi n dan step size h yang digunakan. Lakukan integrasi menggunakan persamaan diatas. Contoh Soal Membuat program untuk menyelesaikan persamaan differensial berikut menggunakan Metode Euler dy/dx = 1 + x^2, y(1) = -4 Untuk menentukan y(1.01), y(1.02) dan y(1.03) Listing Program print(\"f(x,y) = 1+x^2\") print(\"(yi+1) = y1 + h f(xi+yi)\") xi = float(input(\"Masukkan xi = \")) yi = float(input(\"Masukkan yi = \")) h = 1.01-xi #Mengurangi 1.01 dengan x - awal dengan 1 menghasilkan 0.01 n = 4 #Jumlah iterasi yg dipakai 4 karena ada y(1),y(1.01),y(1.02),y(1.03) def f(x,y): return 1+x**2 def metode_euler(xi,yi,h,n): nilai = yi for i in range(n): print(\"Nilai dari x\"+str(i)+\" = \",str(xi) +\" dan y\"+str(i)+\" = \", str(nilai)) nilai = yi + h*f(xi,yi) xi=xi+h yi=nilai metode_euler(xi,yi,h,n) Output f(x,y) = 1+x^2 (yi+1) = y1 + h f(xi+yi) Masukkan xi = 1 Masukkan yi = -4 Nilai dari x0 = 1.0 dan y0 = -4.0 Nilai dari x1 = 1.01 dan y1 = -3.98 Nilai dari x2 = 1.02 dan y2 = -3.959799 Nilai dari x3 = 1.03 dan y3 = -3.9393949999999998","title":"Euler Method"},{"location":"euler/#metode-euler","text":"Dalam matematika dan ilmu komputasi, metode euler juga disebut metode forward euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan differensial biasa dengan nilai awal yang diberikan. Metode Euler adalah salah satu metode satu langkah paling sederhana. Dibandingkan dengan beberapa metode lain, metode ini paling tidak teliti. Namun, metode ini perlu dipelajari mengingat kesederhanaan dan pemahaman yang mudah sehingga membuatnya lebih mudah untuk mempelajari metode lain secara lebih menyeluruh. Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Penyelesaian initial value problems menggunakan metode Euler dilakukan melalui persamaan yi + 1 = yi + f(xi,yi) h dimana i merupakan tahap iterasi. Algoritma Metode Euler Tentukan titik awal integrasi x0 dan y0 Tentukan jumlah iterasi n dan step size h yang digunakan. Lakukan integrasi menggunakan persamaan diatas. Contoh Soal Membuat program untuk menyelesaikan persamaan differensial berikut menggunakan Metode Euler dy/dx = 1 + x^2, y(1) = -4 Untuk menentukan y(1.01), y(1.02) dan y(1.03) Listing Program print(\"f(x,y) = 1+x^2\") print(\"(yi+1) = y1 + h f(xi+yi)\") xi = float(input(\"Masukkan xi = \")) yi = float(input(\"Masukkan yi = \")) h = 1.01-xi #Mengurangi 1.01 dengan x - awal dengan 1 menghasilkan 0.01 n = 4 #Jumlah iterasi yg dipakai 4 karena ada y(1),y(1.01),y(1.02),y(1.03) def f(x,y): return 1+x**2 def metode_euler(xi,yi,h,n): nilai = yi for i in range(n): print(\"Nilai dari x\"+str(i)+\" = \",str(xi) +\" dan y\"+str(i)+\" = \", str(nilai)) nilai = yi + h*f(xi,yi) xi=xi+h yi=nilai metode_euler(xi,yi,h,n) Output f(x,y) = 1+x^2 (yi+1) = y1 + h f(xi+yi) Masukkan xi = 1 Masukkan yi = -4 Nilai dari x0 = 1.0 dan y0 = -4.0 Nilai dari x1 = 1.01 dan y1 = -3.98 Nilai dari x2 = 1.02 dan y2 = -3.959799 Nilai dari x3 = 1.03 dan y3 = -3.9393949999999998","title":"Metode Euler"},{"location":"gaus/","text":"Metode Eliminasi Gauss Eliminasi Gauss ialah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya ialah melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Mencari solusi persamaan linear dengan membuat matrix triangular atas terdiri dari dua tahap : Forward Elimination (eliminasi maju) - Tujuan Forward Elimination adalah untuk membentuk matriks koefisien menjadi Upper Triangular Matrix. Backward substitution (substitusi mundur) - Proses penyelesaian sistem persamaan linear yang telah diubah menjadi bentuk eselon baris atau bentuk eselon baris tereduksi. Persamaan terakhir diselesaikan pertama, lalu selanjutnya ke terakhir. Eliminasi Gauss Jordan Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma : masukkan matrik A, dan vektor B beserta ukurannya n buat augmented matrik [A|B] namakan dengan A Untuk baris ke i dimana i=1 s/d n a. perhatikan nilai a(i,i) sama dengan 0 jika iya maka baris ke i dan baris i+k<=n, dimana a(i+k,i) tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. jika tidak maka dilanjutkan b. Jadikan nilai diagonalnya menjadi satu,dengan cara untuk setiap kolam k dimana k=1 s/d n+1, hitung $$ a(i,k) = a(i,k) / a(i,j) $$. Contoh Program Persamaan: | 2 5 3 = 1 | | 3 4 2 = -3 | | 1 3 1 = 2 | import numpy as np #Definisi Matrix m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) print() #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai x',m+1, '=',x[m]) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 2 Masukkan a1,2: 5 Masukkan a1,3: 3 Masukkan Hasil: 1 Masukkan a2,1: 3 Masukkan a2,2: 4 Masukkan a2,3: 2 Masukkan Hasil: -3 Masukkan a3,1: 1 Masukkan a3,2: 3 Masukkan a3,3: 1 Masukkan Hasil: 2 Matrix A : [[ 2. 5. 3. ] [ 0. -3.5 -2.5 ] [ 0. 0. -0.85714286]] Nilai x 3 = -1.0000000000000002 Nilai x 2 = 2.0 Nilai x 1 = -2.9999999999999996 Diperoleh Hasil x = -3 y = 2 z = -1 Eliminasi Gauss Jacobi Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Contoh Program Persamaan | 3 1 -1 = 5 | | 4 7 -3 = 20 | | 2 -2 5 =10 | from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): if x is None: x = zeros(len(A[0])) D = diag(A) R = A - diagflat(D) for i in range(N): x = (b - dot(R,x)) / D return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix = array(a,float) Hasil = array(b,float) x=len(a) guess = np.zeros(x,float) sol = jacobi(Matrix,Hasil,N=25,x=guess) print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print(\"x:\") pprint(sol) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 3 Masukkan a1,2: 1 Masukkan a1,3: -1 Masukkan Hasil: 5 Masukkan a2,1: 4 Masukkan a2,2: 7 Masukkan a2,3: -3 Masukkan Hasil: 20 Masukkan a3,1: 2 Masukkan a3,2: -2 Masukkan a3,3: 5 Masukkan Hasil: 10 Matrix: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) Hasil: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Eliminasi Gauss Seindel Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. Kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. Kekurangannya atau Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar. Contoh Program Persamaan | 4 -1 1 = 7 | | 4 -8 1 = -21 | | -2 1 5 = 15 | from pprint import pprint import numpy as np def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print() for i in range(0, 100): x = seidel(a, x, b) print(\"Jawaban :\",x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 Matrix: array([[ 4., -1., 1.], [ 4., -8., 1.], [-2., 1., 5.]]) Hasil: array([ 7., -21., 15.]) Jawaban : [2.0, 4.0, 3.0] Iterasi yang digunakan sebanyak 100 iterasi, sehingga dapat menghasilkan: x = 2 y = 4 z = 3.","title":"Gauss Elimination"},{"location":"gaus/#metode-eliminasi-gauss","text":"Eliminasi Gauss ialah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya ialah melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Mencari solusi persamaan linear dengan membuat matrix triangular atas terdiri dari dua tahap : Forward Elimination (eliminasi maju) - Tujuan Forward Elimination adalah untuk membentuk matriks koefisien menjadi Upper Triangular Matrix. Backward substitution (substitusi mundur) - Proses penyelesaian sistem persamaan linear yang telah diubah menjadi bentuk eselon baris atau bentuk eselon baris tereduksi. Persamaan terakhir diselesaikan pertama, lalu selanjutnya ke terakhir.","title":"Metode Eliminasi Gauss"},{"location":"gaus/#eliminasi-gauss-jordan","text":"Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma : masukkan matrik A, dan vektor B beserta ukurannya n buat augmented matrik [A|B] namakan dengan A Untuk baris ke i dimana i=1 s/d n a. perhatikan nilai a(i,i) sama dengan 0 jika iya maka baris ke i dan baris i+k<=n, dimana a(i+k,i) tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. jika tidak maka dilanjutkan b. Jadikan nilai diagonalnya menjadi satu,dengan cara untuk setiap kolam k dimana k=1 s/d n+1, hitung $$ a(i,k) = a(i,k) / a(i,j) $$. Contoh Program Persamaan: | 2 5 3 = 1 | | 3 4 2 = -3 | | 1 3 1 = 2 | import numpy as np #Definisi Matrix m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) print() #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai x',m+1, '=',x[m]) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 2 Masukkan a1,2: 5 Masukkan a1,3: 3 Masukkan Hasil: 1 Masukkan a2,1: 3 Masukkan a2,2: 4 Masukkan a2,3: 2 Masukkan Hasil: -3 Masukkan a3,1: 1 Masukkan a3,2: 3 Masukkan a3,3: 1 Masukkan Hasil: 2 Matrix A : [[ 2. 5. 3. ] [ 0. -3.5 -2.5 ] [ 0. 0. -0.85714286]] Nilai x 3 = -1.0000000000000002 Nilai x 2 = 2.0 Nilai x 1 = -2.9999999999999996 Diperoleh Hasil x = -3 y = 2 z = -1","title":"Eliminasi Gauss Jordan"},{"location":"gaus/#eliminasi-gauss-jacobi","text":"Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Contoh Program Persamaan | 3 1 -1 = 5 | | 4 7 -3 = 20 | | 2 -2 5 =10 | from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): if x is None: x = zeros(len(A[0])) D = diag(A) R = A - diagflat(D) for i in range(N): x = (b - dot(R,x)) / D return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix = array(a,float) Hasil = array(b,float) x=len(a) guess = np.zeros(x,float) sol = jacobi(Matrix,Hasil,N=25,x=guess) print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print(\"x:\") pprint(sol) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 3 Masukkan a1,2: 1 Masukkan a1,3: -1 Masukkan Hasil: 5 Masukkan a2,1: 4 Masukkan a2,2: 7 Masukkan a2,3: -3 Masukkan Hasil: 20 Masukkan a3,1: 2 Masukkan a3,2: -2 Masukkan a3,3: 5 Masukkan Hasil: 10 Matrix: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) Hasil: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Eliminasi Gauss Jacobi"},{"location":"gaus/#eliminasi-gauss-seindel","text":"Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. Kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. Kekurangannya atau Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar. Contoh Program Persamaan | 4 -1 1 = 7 | | 4 -8 1 = -21 | | -2 1 5 = 15 | from pprint import pprint import numpy as np def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print() for i in range(0, 100): x = seidel(a, x, b) print(\"Jawaban :\",x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 Matrix: array([[ 4., -1., 1.], [ 4., -8., 1.], [-2., 1., 5.]]) Hasil: array([ 7., -21., 15.]) Jawaban : [2.0, 4.0, 3.0] Iterasi yang digunakan sebanyak 100 iterasi, sehingga dapat menghasilkan: x = 2 y = 4 z = 3.","title":"Eliminasi Gauss Seindel"},{"location":"richardson/","text":"Richardson Extrapolation Dalam analisis numerik,ekstrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Ekstrapolasi Richardson diterapkan pada barisan pendekatan nilai opsi untuk mempercepat laju konvergensinya. Aplikasi praktis ekstrapolasi Richardson termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Metode Richardson tidak dapat menghasilkan estimasi untuk kesalahan perkiraan. Salah satu cara untuk memperkirakan kesalahan adalah dengan melakukan dua ekstrapolasi dengan NN yang sedikit berbeda dan membandingkan hasilnya. Ekstrapolasi Richardson tidak berfungsi untuk urutan berosilasi. Sebagai solusi sederhana, richardson mendeteksi jika tiga elemen terakhir tidak berbeda secara monoton, dan dalam hal itu berlaku ekstrapolasi hanya untuk elemen indeks genap. Teori Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h^n + o(h^n) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) e = a(h/2) + K/2n h^n + o(h^n) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n^e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h^n \u2212 K h^n + o(h^n) Perhatikan bahwa istilah hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h^n) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn. Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h^2, etc. Contoh Program from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) print(\"Estimasi , f'(x) = \",L[i][j]) return L[0][k-1] print(\"Diferensiasi numerik dari\") print(\"f(x) = -0.1*x**4 -0.15*x**3 -0.5*x**2 -0.25*x +1.2 dengan x=0.5\") print(\"h1 = 0.5\") print(\"h2 = 0.5/2=0.25\") print() print('Estimasi pada f(0.5) = %04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print() print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) Output Diferensiasi numerik dari f(x) = -0.1*x**4 -0.15*x**3 -0.5*x**2 -0.25*x +1.2 dengan x=0.5 h1 = 0.5 h2 = 0.5/2=0.25 Estimasi , f'(x) = -0.9125000000000038 Estimasi , f'(x) = -0.912500000000005 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi pada f(0.5) = -0.91250000000000530687 Estimasi , f'(x) = 0.168495583979535 Estimasi , f'(x) = 0.16849558398154443 Estimasi , f'(x) = 0.16849558398154296 Estimasi , f'(x) = 0.1684955839815426 Estimasi , f'(x) = 0.16849558398154252 Estimasi , f'(x) = 0.1684955839815425 Estimasi , f'(x) = 0.1684955839815425 Estimasi , f'(x) = 0.1684955839815425 diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah 0.16849558398154249050","title":"Richardson Extrapolation"},{"location":"richardson/#richardson-extrapolation","text":"Dalam analisis numerik,ekstrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Ekstrapolasi Richardson diterapkan pada barisan pendekatan nilai opsi untuk mempercepat laju konvergensinya. Aplikasi praktis ekstrapolasi Richardson termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Metode Richardson tidak dapat menghasilkan estimasi untuk kesalahan perkiraan. Salah satu cara untuk memperkirakan kesalahan adalah dengan melakukan dua ekstrapolasi dengan NN yang sedikit berbeda dan membandingkan hasilnya. Ekstrapolasi Richardson tidak berfungsi untuk urutan berosilasi. Sebagai solusi sederhana, richardson mendeteksi jika tiga elemen terakhir tidak berbeda secara monoton, dan dalam hal itu berlaku ekstrapolasi hanya untuk elemen indeks genap. Teori Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h^n + o(h^n) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) e = a(h/2) + K/2n h^n + o(h^n) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n^e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h^n \u2212 K h^n + o(h^n) Perhatikan bahwa istilah hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h^n) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn. Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h^2, etc. Contoh Program from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) print(\"Estimasi , f'(x) = \",L[i][j]) return L[0][k-1] print(\"Diferensiasi numerik dari\") print(\"f(x) = -0.1*x**4 -0.15*x**3 -0.5*x**2 -0.25*x +1.2 dengan x=0.5\") print(\"h1 = 0.5\") print(\"h2 = 0.5/2=0.25\") print() print('Estimasi pada f(0.5) = %04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print() print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) Output Diferensiasi numerik dari f(x) = -0.1*x**4 -0.15*x**3 -0.5*x**2 -0.25*x +1.2 dengan x=0.5 h1 = 0.5 h2 = 0.5/2=0.25 Estimasi , f'(x) = -0.9125000000000038 Estimasi , f'(x) = -0.912500000000005 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi , f'(x) = -0.9125000000000053 Estimasi pada f(0.5) = -0.91250000000000530687 Estimasi , f'(x) = 0.168495583979535 Estimasi , f'(x) = 0.16849558398154443 Estimasi , f'(x) = 0.16849558398154296 Estimasi , f'(x) = 0.1684955839815426 Estimasi , f'(x) = 0.16849558398154252 Estimasi , f'(x) = 0.1684955839815425 Estimasi , f'(x) = 0.1684955839815425 Estimasi , f'(x) = 0.1684955839815425 diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah 0.16849558398154249050","title":"Richardson Extrapolation"},{"location":"romberg/","text":"Metode Romberg Metode Romberg adalah metode perhitungan yang didasarkan trapezional rule dan error calcultion sehingga dapat menghasilan nilai integral dengan tingkat presisi yang tinggi. Metode integrasi Romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Metode ini sering digunakan untuk memperbaiki hasil aproksimasi oleh metode selisih terhingga. Metode ini dipakai untuk evaluasi numerik dari integral tentu. Untuk dua interval bagian yang berbeda yang panjangnya h1 dan h2 akan diperoleh aproksimasi nilai-nilai I1 dan I2, kemudian diperoleh kekeliruan E1 dan E2. Algoritma : Mendefinisikan fungsi integral f(x) Menentukan batas-batas integral dengan nilai konstanta Menentukan jumlah iterasi (N) Menentukan nilai interval pada [a,b] atau bisa dengan [x2,x1] lalu menghitung h nya dengan cara : h=x2\u2212x1 Menghitung nilai integrasi pada kolom pertama dengan rumus : R(1,1) = T0 = h2(f(x1,y)+f(x2,y)) Menghitung nilai integrasi pada baris kedua sampai n pada kolom pertama dengan rumus : $$ R(n,1) = T_{k+1} = {T_k \\over 2} + {h \\over 2^{k+1}} \\sum^{2^k} {n=1}f {2r-1};f(i) = f(x_1+ i {h \\over 2^{k+1}}, n>=2) $$ Menghitung nilai integrasi pada kolom kedua sampai n dengan menggunakan rumus integrasi Romberg : R(n,m) = 4m\u22121R(n,m\u22121)\u2212R(n\u22121,m\u22121) / 4m\u22121\u22121 Integrasi Romberg juga dapat diartikan sebagai teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( ekstrapolasi Richardson ( Richardso Richardson\u2019s n\u2019s extrapol extrapolation ation), yaitu metode untuk mengkombinasikan ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( integral dalam batas toleransi kesalahan (error tolerance error tolerance) yang sudah ditentukan terlebih dahulu. ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode t kesalahan metode trapesium \u201ccukup\u201d besar rapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi pangkat tinggidan fungsi transeden. Contoh Program import numpy as np def trapezcomp(f, a, b, n): #Inisialisasi h = (b - a) / n x = a #Aturan komposit In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): I = np.zeros((p, p)) for k in range(0, p): #Aturan trapesium komposit untuk 2 ^ k I[k, 0] = trapezcomp(f, a, b, 2**k) #Rumus rekursif romberg for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) #Menampilkan hasil print(I[k, 0:k+1]) return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(\"Solusi yang didapatkan =\",solution) Output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] Solusi yang didapatkan = 1.0000000081440203 Keterangan f : fungsi untuk diintegrasikan. a : batas bawah integrasi. b : batas atas. n : jumlah panel untuk dibuat antara a dan b. p : jumlah baris dalam tabel Romberg.","title":"Romberg Method"},{"location":"romberg/#metode-romberg","text":"Metode Romberg adalah metode perhitungan yang didasarkan trapezional rule dan error calcultion sehingga dapat menghasilan nilai integral dengan tingkat presisi yang tinggi. Metode integrasi Romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Metode ini sering digunakan untuk memperbaiki hasil aproksimasi oleh metode selisih terhingga. Metode ini dipakai untuk evaluasi numerik dari integral tentu. Untuk dua interval bagian yang berbeda yang panjangnya h1 dan h2 akan diperoleh aproksimasi nilai-nilai I1 dan I2, kemudian diperoleh kekeliruan E1 dan E2. Algoritma : Mendefinisikan fungsi integral f(x) Menentukan batas-batas integral dengan nilai konstanta Menentukan jumlah iterasi (N) Menentukan nilai interval pada [a,b] atau bisa dengan [x2,x1] lalu menghitung h nya dengan cara : h=x2\u2212x1 Menghitung nilai integrasi pada kolom pertama dengan rumus : R(1,1) = T0 = h2(f(x1,y)+f(x2,y)) Menghitung nilai integrasi pada baris kedua sampai n pada kolom pertama dengan rumus : $$ R(n,1) = T_{k+1} = {T_k \\over 2} + {h \\over 2^{k+1}} \\sum^{2^k} {n=1}f {2r-1};f(i) = f(x_1+ i {h \\over 2^{k+1}}, n>=2) $$ Menghitung nilai integrasi pada kolom kedua sampai n dengan menggunakan rumus integrasi Romberg : R(n,m) = 4m\u22121R(n,m\u22121)\u2212R(n\u22121,m\u22121) / 4m\u22121\u22121 Integrasi Romberg juga dapat diartikan sebagai teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( ekstrapolasi Richardson ( Richardso Richardson\u2019s n\u2019s extrapol extrapolation ation), yaitu metode untuk mengkombinasikan ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( integral dalam batas toleransi kesalahan (error tolerance error tolerance) yang sudah ditentukan terlebih dahulu. ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode t kesalahan metode trapesium \u201ccukup\u201d besar rapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi pangkat tinggidan fungsi transeden. Contoh Program import numpy as np def trapezcomp(f, a, b, n): #Inisialisasi h = (b - a) / n x = a #Aturan komposit In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): I = np.zeros((p, p)) for k in range(0, p): #Aturan trapesium komposit untuk 2 ^ k I[k, 0] = trapezcomp(f, a, b, 2**k) #Rumus rekursif romberg for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) #Menampilkan hasil print(I[k, 0:k+1]) return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(\"Solusi yang didapatkan =\",solution) Output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] Solusi yang didapatkan = 1.0000000081440203 Keterangan f : fungsi untuk diintegrasikan. a : batas bawah integrasi. b : batas atas. n : jumlah panel untuk dibuat antara a dan b. p : jumlah baris dalam tabel Romberg.","title":"Metode Romberg"},{"location":"root/","text":"Numerical Solution of Algebraic and Transcendental Equation Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma: Definisikan fungsi f(x) yang akan dicari akarnya Tentukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x = (a+b)/2 Hitung f(x) Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835 Regula Falsi Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Algoritma: Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : [ c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) ] Akar persamaanya = c Contoh Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259 Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Prosedur: Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Contoh Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035 Secant Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n [ x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) ] Akar persamaan adalah nilai x yang terakhir Contoh Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Numerical Solution"},{"location":"root/#numerical-solution-of-algebraic-and-transcendental-equation","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant.","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"root/#bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma: Definisikan fungsi f(x) yang akan dicari akarnya Tentukan nilai a dan b Tentukan toleransi e dan iterasi maksimum N Hitung f(a) dan f(b) Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x = (a+b)/2 Hitung f(x) Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835","title":"Bisection"},{"location":"root/#regula-falsi","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Algoritma: Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : [ c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) ] Akar persamaanya = c Contoh Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259","title":"Regula Falsi"},{"location":"root/#newton-raphson","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Prosedur: Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Contoh Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035","title":"Newton Raphson"},{"location":"root/#secant","text":"Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n [ x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) ] Akar persamaan adalah nilai x yang terakhir Contoh Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Secant"}]}